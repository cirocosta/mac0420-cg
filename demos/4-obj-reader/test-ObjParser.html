<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Assets tests</title>
    <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.17.1.css">
    <script src="http://code.jquery.com/qunit/qunit-1.17.1.js"></script>
    <script src="ObjParser.js"></script>
  </head>

  <body>
    <div id="qunit"></div>
  </body>

<script>
var rounder = function (num) {
  return Math.round(num * Math.pow(10,3))/Math.pow(10,3);
};

/**
 * Represents a real cube generated by blender.
 */
var OBJ_1 = [
  '# Blender v2.71 (sub 0) OBJ File:',
  '# www.blender.org',
  'mtllib untitled.mtl',
  'o Cube',
  'v 1.000000 -1.000000 -1.000000',
  'v 1.000000 -1.000000 1.000000',
  'v -1.000000 -1.000000 1.000000',
  'v -1.000000 -1.000000 -1.000000',
  'v 1.000000 1.000000 -0.999999',
  'v 0.999999 1.000000 1.000001',
  'v -1.000000 1.000000 1.000000',
  'v -1.000000 1.000000 -1.000000',
  'usemtl Material',
  's off',
  'f 1 2 3 4',
  'f 5 8 7 6',
  'f 1 5 6 2',
  'f 2 6 7 3',
  'f 3 7 8 4',
  'f 5 1 4 8',
].join('\n');

/**
 * Fake data that will hold a bunch of cases
 */
var OBJ_2 = [
  '# Comment',
  'v 1.000000 -1.000000',
  'v 1.000000 -1.000000 -1.000000',
  'vn 0.707 0.000 0.707',
  'f 1 2 3 4',
  'f 3/1 4/2 5/3',
  'f 6/4/1 3/5/3 7/6/5',
  'f 4093//7613 4092//7613 4084//7613',
].join('\n');

QUnit.module("ObjParser");
QUnit.test("::ObjParser", function (assert) {
  assert.ok(window.ObjParser, "ObjParser should be declared in the window obj");
  assert.ok(ObjParser, "ObjParser should be declared in the global context");
});

QUnit.test("::parse", function (assert) {
  // OBJ_1

  var lines = OBJ_1.split('\n');
  assert.ok(!ObjParser.parse(lines[0]).vertices.length,
            'comment shouldn\'t produce vertices, etc');
  assert.ok(ObjParser.parse(lines[4]).vertices.length,
            'vertex line should produce vertices');
  assert.deepEqual(ObjParser.parse(lines[4]).vertices,
            [[1.000, -1.000, -1.000]],
            'vertex line should be parsed correctly with 3 comps');

  var expected = [
    [1.000000,-1.000000,-1.000000],
    [1.000000,-1.000000,1.000000],
    [-1.000000,-1.000000,1.000000],
    [-1.000000,-1.000000,-1.000000],
    [1.000000,1.000000,-0.999999],
    [0.999999,1.000000,1.000001],
    [-1.000000,1.000000,1.000000],
    [-1.000000,1.000000,-1.000000],
  ];

  assert.deepEqual(ObjParser.parse(OBJ_1).vertices,
            expected,
            'all vertex lines should be parsed');

  // OBJ_2

  lines = OBJ_2.split('\n');
  assert.deepEqual(ObjParser.parse(lines[3]).vertices_normals,
            [[0.707 ,0.000, 0.707]],
            'vertices_normals line should be parsed correctly with 3 comps');

  assert.deepEqual(ObjParser.parse('f 1 2 3 4').faces,
                   [[1., 2., 3., 4.]], 'faces');
  assert.deepEqual(ObjParser.parse('f 3/1 4/2 5/3').faces2,
                   [[[3,1], [4,2], [5,3]]], 'faces2');
  assert.deepEqual(ObjParser.parse('f 6/4/1 3/5/3 7/6/5').faces3,
                   [[[6,4,1], [3,5,3], [7,6,5]]], 'faces3');
  assert.deepEqual(
      ObjParser.parse('f 1//2 3//4 5//6').faces4,
      [[[1,,2], [3,,4], [5,,6]]],
      'faces4 without texture');
  assert.deepEqual(
      ObjParser.parse('f 1//2 3//4 5//6 7//8').faces4,
      [[[1,,2], [3,,4], [5,,6], [7,,8]]],
      'faces4 quad without texture');
});
</script>
</html>
