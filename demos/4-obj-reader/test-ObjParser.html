<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Assets tests</title>
    <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.17.1.css">
    <script src="http://code.jquery.com/qunit/qunit-1.17.1.js"></script>
    <script type="application/javascript;version=1.7" src="ObjParser.js"></script>
    <script src="../../assets/cuon.js"></script>
  </head>

  <body>
    <div id="qunit"></div>
  </body>

<script type="application/javascript;version=1.7">

/**
 * Represents a real cube generated by blender.
 */
var OBJ_1 = [
  '# Blender v2.71 (sub 0) OBJ File:',
  '# www.blender.org',
  'mtllib untitled.mtl',
  'o Cube',
  'v 1.000000 -1.000000 -1.000000',
  'v 1.000000 -1.000000 1.000000',
  'v -1.000000 -1.000000 1.000000',
  'v -1.000000 -1.000000 -1.000000',
  'v 1.000000 1.000000 -0.999999',
  'v 0.999999 1.000000 1.000001',
  'v -1.000000 1.000000 1.000000',
  'v -1.000000 1.000000 -1.000000',
  'usemtl Material',
  's off',
  'f 1 2 3 4',
  'f 5 8 7 6',
  'f 1 5 6 2',
  'f 2 6 7 3',
  'f 3 7 8 4',
  'f 5 1 4 8',
].join('\n');

/**
 * Fake data that will hold a bunch of cases
 */
var OBJ_2 = [
  '# Comment',
  'v 1.000000 -1.000000',
  'v 1.000000 -1.000000 -1.000000',
  'vn 0.707 0.000 0.707',
  'f 1 2 3 4',
  'f 3/1 4/2 5/3',
  'f 6/4/1 3/5/3 7/6/5',
  'f 4093//7613 4092//7613 4084//7613',
].join('\n');

QUnit.module("ObjParser");
QUnit.test("::ObjParser", function (assert) {
  assert.ok(window.ObjParser, "ObjParser should be declared in the window obj");
  assert.ok(ObjParser, "ObjParser should be declared in the global context");
});

QUnit.module("::parse");
QUnit.test("vertices", function (assert) {
  var lines = OBJ_1.split('\n');
  assert.ok(!ObjParser.parse(lines[0]).vertices.length,
            'comment shouldn\'t produce vertices, etc');
  assert.ok(ObjParser.parse(lines[4]).vertices.length,
            'vertex line should produce vertices');
  assert.deepEqual(ObjParser.parse(lines[4]).vertices,
            [1.000, -1.000, -1.000],
            'vertex line should be parsed correctly with 3 comps');
});

QUnit.test("vertices from generated blender obj", function (assert) {
  var expected = [
    1.000000,-1.000000,-1.000000,
    1.000000,-1.000000,1.000000,
    -1.000000,-1.000000,1.000000,
    -1.000000,-1.000000,-1.000000,
    1.000000,1.000000,-0.999999,
    0.999999,1.000000,1.000001,
    -1.000000,1.000000,1.000000,
    -1.000000,1.000000,-1.000000,
  ];

  assert.deepEqual(ObjParser.parse(OBJ_1).vertices, expected,
                   'all vertex from OBJ1 lines should be parsed correctly');
});

  // OBJ_2
QUnit.test("vertice normals from blender obj", function (assert) {
  lines = OBJ_2.split('\n');
  assert.deepEqual(ObjParser.parse(lines[3]).vertices_normals,
            [0.707 ,0.000, 0.707],
            'vertices_normals line should be parsed correctly with 3 comps');
});

QUnit.module("::parse - faces - w/out norm/text");
QUnit.test("produce flat array w/ stride of 3 for quads", function (assert) {
  let actual = ObjParser.parse('f 1 2 3 4', true);
  let expected = [0, 1, 2, 2, 3, 0];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE);
  assert.deepEqual(actual.faces, expected);
  assert.ok(!(actual.faces.length%3));
});

QUnit.test("produce flat array w/ stride of 3 for triangs", function (assert) {
  let actual = ObjParser.parse('f 1 2 3', true);
  let expected = [0, 1, 2];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE);
  assert.deepEqual(actual.faces, expected);
  assert.ok(!(actual.faces.length%3));
});

  // assert.deepEqual(ObjParser.parse('f 1//1 2//1 3//1 4//1', true).faces,
  //                  ['1//1', '2//1', '3//1', '4//1',])
  // assert.deepEqual(ObjParser.parse('f 3/1 4/2 5/3').faces,
  //                  [['3/1', '4/2', '5/3']], 'faces2');
  // assert.deepEqual(ObjParser.parse('f 6/4/1 3/5/3 7/6/5').faces,
  //                  [['6/4/1', '3/5/3', '7/6/5']], 'faces3');
  // assert.deepEqual(
  //     ObjParser.parse('f 1//2 3//4 5//6').faces,
  //     [['1//2', '3//4', '5//6']],
  //     'faces4 without texture');
  // assert.deepEqual(
  //     ObjParser.parse('f 1//2 3//4 5//6 7//8', true).faces,
  //     [["1//2", "3//4", "5//6"], ["5//6", "7//8", "1//2"]],
  //     'faces4 quad without texture');
// });

QUnit.module("::getNormal");
QUnit.test('should properly obtain normal from 3 points', function (assert) {
  var a = [1.0, 0.0, 1.0];
  var b = [1.0, 0.0, 0.0];
  var c = [-1.0, 0.0, 0.0];

  assert.deepEqual(ObjParser.getNormal(a,b,c), new Float32Array([0,1,0]));
});
</script>
</html>
