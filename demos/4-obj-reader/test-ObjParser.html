<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Assets tests</title>
    <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.17.1.css">
    <script src="http://code.jquery.com/qunit/qunit-1.17.1.js"></script>
    <script type="application/javascript;version=1.7" src="ObjParser.js"></script>
    <script src="../../assets/cuon.js"></script>
  </head>

  <body>
    <div id="qunit"></div>
  </body>

<script type="application/javascript;version=1.7">

/**
 * Represents a real cube generated by blender.
 */
let OBJ_1 = [
  '# Blender v2.71 (sub 0) OBJ File:',
  '# www.blender.org',
  'mtllib untitled.mtl',
  'o Cube',
  'v 1.000000 -1.000000 -1.000000',
  'v 1.000000 -1.000000 1.000000',
  'v -1.000000 -1.000000 1.000000',
  'v -1.000000 -1.000000 -1.000000',
  'v 1.000000 1.000000 -0.999999',
  'v 0.999999 1.000000 1.000001',
  'v -1.000000 1.000000 1.000000',
  'v -1.000000 1.000000 -1.000000',
  'usemtl Material',
  's off',
  'f 1 2 3 4',
  'f 5 8 7 6',
  'f 1 5 6 2',
  'f 2 6 7 3',
  'f 3 7 8 4',
  'f 5 1 4 8',
].join('\n');

/**
 * Fake data that will hold a bunch of cases
 */
let OBJ_2 = [
  '# Comment',
  'v 1.000000 -1.000000',
  'v 1.000000 -1.000000 -1.000000',
  'vn 0.707 0.000 0.707',
  'f 1 2 3 4',
  'f 3/1 4/2 5/3',
  'f 6/4/1 3/5/3 7/6/5',
  'f 4093//7613 4092//7613 4084//7613',
].join('\n');


QUnit.module("ObjParser");
QUnit.test("::ObjParser", (assert) => {
  assert.ok(window.ObjParser, "ObjParser should be declared in the window obj");
  assert.ok(ObjParser, "ObjParser should be declared in the global context");
});


QUnit.module("::parse");
QUnit.test("vertices", (assert) => {
  var lines = OBJ_1.split('\n');
  assert.ok(!ObjParser.parse(lines[0]).vertices_coords.length,
            'comment shouldn\'t produce vertices, etc');
  assert.ok(ObjParser.parse(lines[4]).vertices_coords.length,
            'vertex line should produce vertices');
  assert.deepEqual(ObjParser.parse(lines[4]).vertices_coords,
            [1.000, -1.000, -1.000],
            'vertex line should be parsed correctly with 3 comps');
});

QUnit.test("vertices from generated blender obj", (assert) => {
  var expected = [
    1.000000,-1.000000,-1.000000,
    1.000000,-1.000000,1.000000,
    -1.000000,-1.000000,1.000000,
    -1.000000,-1.000000,-1.000000,
    1.000000,1.000000,-0.999999,
    0.999999,1.000000,1.000001,
    -1.000000,1.000000,1.000000,
    -1.000000,1.000000,-1.000000,
  ];

  assert.deepEqual(ObjParser.parse(OBJ_1).vertices_coords, expected,
                   'all vertex from OBJ1 lines should be parsed correctly');
});

QUnit.test("vertice normals from blender obj", (assert) => {
  lines = OBJ_2.split('\n');
  assert.deepEqual(ObjParser.parse(lines[3]).vertices_normals,
            [0.707 ,0.000, 0.707],
            'vertices_normals line should be parsed correctly with 3 comps');
});


QUnit.module("::parse - faces - FACES_TYPE: FACE");
QUnit.test("produce flat array w/ stride of 3 for quads", (assert) => {
  let actual = ObjParser.parse('f 1 2 3 4', true);
  let expected = [0, 1, 2, 2, 3, 0];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE);
  assert.deepEqual(actual.faces, expected);
  assert.ok(!(actual.faces.length%3));
});

QUnit.test("produce correct vertices given vertices_coords and faces", (assert) => {
  let actual = ObjParser.parse(['v -1.000000 0.000000 0.000000',
                                'v 1.000000 0.000000 0.000000',
                                'v 0.000000 1.000000 0.000000',
                                'v 1.000000 0.000000 1.000000',
                                'f 1 2 3',
                                'f 2 4 3',
                                'f 4 1 3',
                                'f 4 1 2'].join('\n'));

  let expected_vertices = [-1.0, 0.0, 0.0,   1.0, 0.0, 0.0,    0.0, 1.0, 0.0,
                            1.0, 0.0, 0.0,    1.0, 0.0, 1.0,    0.0, 1.0, 0.0,
                            1.0, 0.0, 1.0,    -1.0, 0.0, 0.0,   0.0, 1.0, 0.0,
                            1.0, 0.0, 1.0,    -1.0, 0.0, 0.0,   1.0, 0.0, 0.0];
  let expected_vertices_coords = [-1.000000, 0.000000, 0.000000,
                                  1.000000, 0.000000, 0.000000,
                                  0.000000, 1.000000, 0.000000,
                                  1.000000, 0.000000, 1.000000];

  assert.equal(actual.vertices.length, expected_vertices.length);
  assert.deepEqual(actual.vertices_coords, expected_vertices_coords);
  assert.deepEqual(actual.vertices, expected_vertices);
});

QUnit.test("produce flat array w/ stride of 3 for triangs", (assert) => {
  let actual = ObjParser.parse('f 1 2 3', true);
  let expected = [0, 1, 2];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE);
  assert.deepEqual(actual.faces, expected);
  assert.ok(!(actual.faces.length%3));
});


QUnit.module("::parse - faces - FACES_TYPE: FACE_NORMALS");
QUnit.test('quad to triang; flat faces and normals indices w/ 0 as index', (assert) => {
  let actual = ObjParser.parse('f 1//1 2//1 3//1 4//1', true);
  let expected_faces = [0, 1, 2, 2, 3, 0];
  let expected_normals = [0, 0, 0, 0, 0, 0];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE_NORMALS);
  assert.deepEqual(actual.faces, expected_faces);
  assert.deepEqual(actual.normals_i, expected_normals);
});

QUnit.test('flat faces and normals indices w/ 0 as index', (assert) => {
  let actual = ObjParser.parse('f 1//1 2//1 3//1', true);
  let expected_faces = [0, 1, 2];
  let expected_normals = [0, 0, 0];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE_NORMALS);
  assert.deepEqual(actual.faces, expected_faces);
  assert.deepEqual(actual.normals_i, expected_normals);
});

QUnit.test('generate corresponding normals according to vertices and faces', (assert) => {
  let actual = ObjParser.parse(['v 1.000000 -1.000000 -1.000000',
                                'v 1.000000 -1.000000 1.000000',
                                'v -1.000000 -1.000000 1.000000',
                                'vn 0.000000 -1.000000 0.000000',
                                'f 1//1 2//1 3//1'].join('\n'));
  let expected_faces = [0, 1, 2];
  let expected_vertices_normals = [0, 0, 0];
  let expected_normals = [0.0, -1.0, 0.0,
                          0.0, -1.0, 0.0,
                          0.0, -1.0, 0.0,];

  assert.equal(actual._facesType, ObjParser.FACES_TYPES.FACE_NORMALS);
  assert.deepEqual(actual.faces, expected_faces);
  assert.deepEqual(actual.normals_i, expected_vertices_normals);
  assert.deepEqual(actual.normals, expected_normals);
});

QUnit.module("::parse - _scale");
QUnit.test('do not scale if it fits the max', (assert) => {
  let actual = ObjParser.parse(['v 1.000000 -1.000000 -1.000000',
                                'v 1.000000 -1.000000 1.000000',
                                'v -1.000000 -1.000000 -1.000000'].join('\n'));
  let expected_scale = 1.0;
  assert.equal(actual._scale, expected_scale);
});

QUnit.test('scale properly', (assert) => {
  let actual = ObjParser.parse(['v 0.500000 -0.500000 -0.500000',
                                'v 0.500000 -0.500000 0.500000',
                                'v -0.500000 -0.500000 -0.500000'].join('\n'));
  let expected_scale = 2.0;
  assert.equal(actual._scale, expected_scale);
});

QUnit.module("::parse - _center_of_mass");
QUnit.test('center of canonical cube should be 0,0,0', (assert) => {
  let actual = ObjParser.parse(['v 1.000000 1.000000 1.000000',
                                'v -1.000000 1.000000 1.000000',
                                'v -1.000000 -1.000000 1.000000',
                                'v 1.000000 -1.000000 1.000000',
                                'v 1.000000 1.000000 -1.000000',
                                'v -1.000000 1.000000 -1.000000',
                                'v -1.000000 -1.000000 -1.000000',
                                'v 1.000000 -1.000000 -1.000000',].join('\n'));
  let expected = [0.0,0.0,0.0];

  assert.deepEqual(actual._center_of_mass, expected);
});

QUnit.test('properly calculate center of mass', (assert) => {
  let actual = ObjParser.parse(['v 1.000000 1.000000 0.500000',
                                'v -1.000000 1.000000 0.500000',
                                'v -1.000000 -1.000000 0.500000',
                                'v 1.000000 -1.000000 0.500000',
                                'v 1.000000 1.000000 -1.000000',
                                'v -1.000000 1.000000 -1.000000',
                                'v -1.000000 -1.000000 -1.000000',
                                'v 1.000000 -1.000000 -1.000000',].join('\n'));
  let expected = [0.0,0.0, -0.08333333333333333]; // ???

  assert.deepEqual(actual._center_of_mass, expected);
});

QUnit.module("::getNormal");
QUnit.test('should properly obtain normal from 3 points', (assert) => {
  let a = [1.0, 0.0, 1.0];
  let b = [1.0, 0.0, 0.0];
  let c = [-1.0, 0.0, 0.0];

  let actual = ObjParser.getNormal(a,b,c);
  let expected = new Float32Array([0,1,0]);

  assert.deepEqual(actual, expected);
});
</script>
</html>
